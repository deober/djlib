from __future__ import annotations
from scipy import integrate
import json
import matplotlib.pyplot as plt
import os
from scipy.integrate import cumulative_trapezoid
import scipy.interpolate
import scipy.optimize
import numpy as np
from glob import glob
import pathlib
import math as m
import djlib.djlib as dj
from typing import List, Tuple, Dict
import copy

mc_lib_dir = pathlib.Path(__file__).parent.resolve()


def find(lst: List, a: float):
    """Finds the index of an element that matches a specified value.
    Args:
        a(float): The value to search for
    Returns:
        match_list[0](int): The index that a match occurrs, assuming there is only one match.
    """
    tolerance = 1e-14
    match_list = [
        i for i, x in enumerate(lst) if np.isclose([x], [a], rtol=tolerance)[0]
    ]
    if len(match_list) == 1:
        return match_list[0]
    elif len(match_list) > 1:
        print("Found more than one match. This is not expected.")
    elif len(match_list) == 0:
        print(
            "\nWARNING: Search value does not match any value in the provided list.\n"
        )


def mc_run_namer(run_params: dict):
    """
    Function to generate a name for a MC simulation based on the run parameters.

    Parameters:
    -----------
    run_params: dict
        Dictionary of run parameters.
        Should include: mu start, stop, & increment; T start, stop, & increment, and supercell transformation matrix.

    Returns:
    --------
    name: str
        Name of the non-lte simulation.
    """
    name = f"mu_{run_params['mu_start']}_{run_params['mu_stop']}T_{run_params['T_start']}_{run_params['T_stop']}"
    return name


def mc_status_updater(run_dir):
    """
    Update status.json in a run directory. Updates to "complete" if results.json exists and is of the right size. Updates to "incomplete" if results.json exists and is of the wrong size.
    """
    status_file = os.path.join(run_dir, "status.json")
    settings_file = os.path.join(run_dir, "mc_settings.json")
    length = read_mc_settings(settings_file)[0].shape[0]
    results_file = os.path.join(run_dir, "results.json")

    run_type = None
    if os.path.exists(results_file):
        # Open the file, and check that 'phi_LTE' is a key in the file.
        with open(results_file) as f:
            results = json.load(f)
        if "phi_LTE" in results.keys():
            run_type = "LTE"
        else:
            run_type = "metropolis"

        if run_type == "metropolis":
            results_length = read_mc_results_file(results_file)[0].shape[0]
        elif run_type == "LTE":
            results_length = read_lte_results(results_file)[0].shape[0]
        if results_length == length:
            status = "complete"
        else:
            status = "incomplete"
    else:
        status = "not_submitted"
    with open(status_file, "w") as f:
        json.dump({"status": status}, f, indent=4)


def mc_run_creator(run_params: dict, run_dir: str):
    """
    Creates a grand canonical monte carlo simulation directory, formats necessary settings files, writes a status file and writes a run_info.json file, which contains run_params.

    Parameters:
    run_params: dict
        Dictionary of run parameters.
        Keys should include: mu_start,
                            mu_stop,
                            mu_increment;
                            T_start,
                            T_stop,
                            T_increment,
                            supercell (a transformation matrix applied to the primitive cell),
                            hours (number of hours to run the simulation),
    run_dir: str
        Path to the directory of the mc run, generated by namer function.

    Returns:
    --------
    None
        Simply creates a directory and writes a mc_settings.json file.
    """
    # Make the run directory
    os.makedirs(run_dir, exist_ok=True)

    # Write the run_params dictionary to a json file called run_info.json
    with open(os.path.join(run_dir, "run_info.json"), "w") as f:
        json.dump(run_params, f)

    # Check that there is a status file called status.json in the run directory. If not, create one, and initialize the status as "not_submitted"
    status_file = os.path.join(run_dir, "status.json")
    if not os.path.exists(status_file):
        with open(status_file, "w") as f:
            json.dump({"status": "not_submitted"}, f)

    # Load and write to the settings file, formatting based on the run_params dictionary.

    mc_settings_file = os.path.join(run_dir, "mc_settings.json")

    mc_template_file = os.path.join(
        mc_lib_dir, "../templates/mc_grand_canonical_template.json"
    )
    with open(mc_template_file) as f:
        mc_template = json.load(f)
    with open(mc_settings_file, "w") as f:
        mc_template["driver"]["initial_conditions"]["param_chem_pot"]["a"] = run_params[
            "mu_start"
        ]
        mc_template["driver"]["final_conditions"]["param_chem_pot"]["a"] = run_params[
            "mu_stop"
        ]
        mc_template["driver"]["incremental_conditions"]["param_chem_pot"][
            "a"
        ] = run_params["mu_increment"]
        mc_template["driver"]["initial_conditions"]["temperature"] = run_params[
            "T_start"
        ]
        mc_template["driver"]["final_conditions"]["temperature"] = run_params["T_stop"]
        mc_template["driver"]["incremental_conditions"]["temperature"] = run_params[
            "T_increment"
        ]
        mc_template["supercell"] = run_params[
            "supercell"
        ]  # TODO: Make sure these keys are how we want them inputted in run_params
        json.dump(mc_template, f, indent=4)

    # Write the slurm submission script to the run directory
    dj.format_slurm_job(
        jobname=mc_run_namer(run_params),
        hours=run_params["hours"],
        user_command="casm monte -s mc_settings.json > mc_results.out",
        output_dir=run_dir,
    )

    # different callables for the gridspace manager probably shouldn't call each other. It makes the callables interdependent which could get very confusing and not modular.
    # mc_status_updater(run_dir)


def mc_lte_run_creator(run_params: dict, run_dir: str):
    """
    Creates a grand canonical monte carlo simulation directory, formats necessary settings files, writes a status file and writes a run_info.json file, which contains run_params.

    Parameters:
    run_params: dict
        Dictionary of run parameters.
        Keys should include: mu_start,
                            mu_stop,
                            mu_increment;
                            T_start,
                            T_stop,
                            T_increment,
                            supercell (a transformation matrix applied to the primitive cell),
                            hours (number of hours to run the simulation),
    run_dir: str
        Path to the directory of the mc run, generated by namer function.

    Returns:
    --------
    None
        Simply creates a directory and writes a mc_settings.json file.
    """
    # Make the run directory
    os.makedirs(run_dir, exist_ok=True)

    # Write the run_params dictionary to a json file called run_info.json
    with open(os.path.join(run_dir, "run_info.json"), "w") as f:
        json.dump(run_params, f)

    # Check that there is a status file called status.json in the run directory. If not, create one, and initialize the status as "not_submitted"
    status_file = os.path.join(run_dir, "status.json")
    if not os.path.exists(status_file):
        with open(status_file, "w") as f:
            json.dump({"status": "not_submitted"}, f)

    # Load and write to the settings file, formatting based on the run_params dictionary.
    mc_settings_file = os.path.join(run_dir, "mc_settings.json")

    mc_template_file = os.path.join(mc_lib_dir, "../templates/mc_lte_template.json")
    with open(mc_template_file) as f:
        mc_template = json.load(f)
    with open(mc_settings_file, "w") as f:
        mc_template["driver"]["initial_conditions"]["param_chem_pot"]["a"] = run_params[
            "mu_start"
        ]
        mc_template["driver"]["final_conditions"]["param_chem_pot"]["a"] = run_params[
            "mu_stop"
        ]
        mc_template["driver"]["incremental_conditions"]["param_chem_pot"][
            "a"
        ] = run_params["mu_increment"]
        mc_template["driver"]["initial_conditions"]["temperature"] = run_params[
            "T_start"
        ]
        mc_template["driver"]["final_conditions"]["temperature"] = run_params["T_stop"]
        mc_template["driver"]["incremental_conditions"]["temperature"] = run_params[
            "T_increment"
        ]
        mc_template["supercell"] = run_params[
            "supercell"
        ]  # TODO: Make sure these keys are how we want them inputted in run_params
        json.dump(mc_template, f, indent=4)

    # Write the slurm submission script to the run directory
    dj.format_slurm_job(
        jobname=mc_run_namer(run_params),
        hours=run_params["hours"],
        user_command="casm monte -s mc_settings.json > mc_results.out",
        output_dir=run_dir,
    )

    # different callables for the gridspace manager probably shouldn't call each other. It makes the callables interdependent which could get very confusing and not modular.
    # mc_status_updater(run_dir)


def mc_run_submitter(run_dir, submit_script_name="submit_slurm.sh"):
    """
    Function to submit a monte carlo simulation to the queue.
    """
    # Open the status.json file; only submit if the status is "not_submitted"
    status_file = os.path.join(run_dir, "status.json")
    with open(status_file) as f:
        status = json.load(f)["status"]
    if status == "not_submitted":
        dj.submit_slurm_job(run_dir, submit_script_name=submit_script_name)
        with open(os.path.join(run_dir, "status.json"), "w") as f:
            json.dump({"status": "submitted"}, f, indent=4)


def mc_run_parser(run_dir):
    """Loads the results.json file as a dictionary, and returns the dictionary.

    Parameters
    ----------
    run_dir : str
        Path to the directory of the mc run.

    Returns
    -------
    results : dict
        Dictionary of the results.json file.
    """
    with open(os.path.join(run_dir, "results.json")) as f:
        results = json.load(f)
    return results


def read_mc_results_file(
    results_file_path: str,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Function to parse mc results.json files.
    Args;
        results_file_path(str): Path to the results.json file for the given monte carlo simulation.
    Returns:
        x: np.ndarray
            Vector of compostitions
        b: np.ndarray
            Vector of beta values
        temperature: np.ndarray
            Vecor of temperature values (K)
        potential_energy: np.ndarray:
            Vector of potential energy values (E-mu*x)
    """
    with open(results_file_path) as f:
        results = json.load(f)

    mu = np.array(results["param_chem_pot(a)"])
    x = np.array(results["<comp(a)>"])
    b = np.array(results["Beta"])
    temperature = np.array(results["T"])
    potential_energy = np.array(results["<potential_energy>"])
    formation_energy = np.array(results["<formation_energy>"])
    return (mu, x, b, temperature, potential_energy, formation_energy)


def read_lte_results(
    results_file_path: str,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Takes a lte results.json file and returns outputs from the simulation.

    Parameters:
    -----------
    results_file_path: str
        Path to lte results.json file.

    Returns:
    --------
    mu: np.ndarray
        Vector of chemical potentials (species "a")
    b: np.ndarray
        Vector of Beta values (1/Temperature).
    t: np.ndarray
        Vector of temperatures.
    x: np.ndarray
        Vector of compositions.
    pot_eng: np.ndarray
        Vector of phi values (grand canonical potential energy)
    """
    with open(results_file_path) as f:
        results = json.load(f)

    mu = np.array(results["param_chem_pot(a)"])
    b = np.array(results["Beta"])
    t = np.array(results["T"])
    x = np.array(results["gs_comp(a)"])
    semi_grand_canonical_free_energy = np.array(results["phi_LTE"])
    formation_energy = np.array(results["gs_formation_energy"])

    return (mu, b, t, x, semi_grand_canonical_free_energy, formation_energy)


def read_mc_settings(settings_file: str) -> Tuple[np.ndarray, np.ndarray]:
    """
    Function to read chemical potential and temperature values from a mc_settings.json file.

    Parameters:
    -----------
    settings_file: str
        Path to mc_settings.json file.

    Returns:
    --------
    mu: np.ndarray
        Vector of chemical potentials (species "a")
    t: np.ndarray
        Vector of temperatures.
    """
    with open(settings_file) as f:
        settings = json.load(f)

    mu_start = settings["driver"]["initial_conditions"]["param_chem_pot"]["a"]
    mu_stop = settings["driver"]["final_conditions"]["param_chem_pot"]["a"]
    mu_increment = settings["driver"]["incremental_conditions"]["param_chem_pot"]["a"]
    t_start = settings["driver"]["initial_conditions"]["temperature"]
    t_stop = settings["driver"]["final_conditions"]["temperature"]
    t_increment = settings["driver"]["incremental_conditions"]["temperature"]

    if mu_increment != 0:
        mu_length = int(np.abs((mu_start - mu_stop) / mu_increment)) + 1
    else:
        mu_length = 1
    if t_increment != 0:
        t_length = int(np.abs((t_start - t_stop) / t_increment)) + 1
    else:
        t_length = 1

    if mu_length == 1:
        mu_values = np.ones(t_length) * mu_start
    elif mu_length > 1:
        mu_values = np.linspace(mu_start, mu_stop, mu_length)
    if t_length == 1:
        t_values = np.ones(mu_length) * t_start
    elif t_length > 1:
        t_values = np.linspace(t_start, t_stop, t_length)

    return (mu_values, t_values)


def read_superdupercell(mc_settings_file: str) -> List:
    """Function to read mu / temperature values as well as superdupercell from a monte carlo settings.json file.

    Parameters:
    -----------
    mc_settings_file: str
        Path to mc_settings.json file.
    Returns:
    --------
    superdupercell: List
        Matrix (list of 3 lists) that describes a supercell for the monte carlo simulation.
    """
    with open(mc_settings_file) as f:
        settings = json.load(f)
    superdupercell = settings["supercell"]
    return superdupercell


class lte_run:
    """Class to parse CASM results from Grand Canonical monte carlo low temperature expansion (lte) calculation results.

    Attributes
    ----------
    path: str
        Path to the directory containing the lte results files.

    Methods
    -------
    read_lte_results:
        Function to parse lte results.json files.
    """

    def __init__(self, lte_dir):
        self.path = lte_dir
        self.read_lte_results()

    def read_lte_results(self):
        results_file = os.path.join(self.path, "results.json")
        with open(results_file) as f:
            results = json.load(f)
        self.mu = results["param_chem_pot(a)"]
        self.b = results["Beta"]
        self.t = results["T"]
        self.x = results["<comp(a)>"]
        self.pot_eng = results["<potential_energy>"]
        self.superdupercell = read_superdupercell(
            os.path.join(self.path, "mc_settings.json")
        )


class constant_t_run:
    """Class to parse CASM results from constant temperature Grand Canonical monte carlo calculations.

    Attributes
    ----------
    path: str
        Path to the directory containing the constant temperature results files.

    Methods
    -------
    integrate_constant_temp_grand_canonical:
        Function to integrate the Grand Canonical Free Energy over varying chemical potential at constant temperature.

    """

    def __init__(self, const_t_dir):
        self.path = const_t_dir
        results_file_path = os.path.join(self.path, "results.json")
        (
            self.mu,
            self.x,
            self.b,
            self.t,
            self.pot_eng,
            self.formation_energy,
        ) = read_mc_results_file(results_file_path)
        self.integrate_constant_temp_grand_canonical()
        self.superdupercell = read_superdupercell(
            os.path.join(self.path, "mc_settings.json")
        )

    def integrate_constant_temp_grand_canonical(self):
        """Function to integrate across mu values at a constant temperature
        Args:
            x(list): Vector of compostitions
            b(list): Vector of beta values
            potential_energy(list): Vector of potential energy values (E-mu*x)
            mu(list): Vector of mu values

        Returns:
            integrated_potential(list): List of grand canonical free energy values corresponding to a fixed temperature / beta value.
        """
        free_energy_reference = self.pot_eng[0]
        integrated_potential = []
        for index, value in enumerate(self.mu):
            index = index + 1
            if index > 0:
                current_mu = self.mu[0:index]
                current_b = self.b[0:index]
                current_x = self.x[0:index]
                integrated_potential.append(
                    (1 / current_b[-1])
                    * (
                        self.b[0] * free_energy_reference
                        + integrate.simpson((-1 * current_b * current_x), current_mu)
                    )
                )
        self.integ_grand_canonical = np.asarray(integrated_potential)


class heating_run:
    """Class to parse CASM results from heating Grand Canonical monte carlo calculations at constant chemical potential.

    Attributes
    ----------
    path: str
        Path to the directory containing the heating results files.

    Methods
    -------
    get_lte_reference_energy:
        Function to look up the lte reference energy at a given chemical potential, from a lte run object.
    integrate_heating_grand_canonical_from_lte:
        Function to integrate the Grand Canonical Free Energy over varying temperature from the end state of a lte run; all at constant chemical potential.

    """

    def __init__(self, heating_dir, lte_run):
        self.path = heating_dir
        results_file_path = os.path.join(self.path, "results.json")
        (
            self.mu,
            self.x,
            self.b,
            self.t,
            self.pot_eng,
            self.formation_energy,
        ) = read_mc_results_file(results_file_path)
        self.get_lte_reference_energy(lte_run)
        self.integrate_heating_grand_canonical_from_lte()
        self.superdupercell = read_superdupercell(
            os.path.join(self.path, "mc_settings.json")
        )

    def get_lte_reference_energy(self, lte_run):
        mu_index = find(lte_run.mu, self.mu[0])
        self.energy_reference = lte_run.pot_eng[mu_index]

    def integrate_heating_grand_canonical_from_lte(self):
        """Function to integrate the grand canonical free energy from monte carlo heating run results.
        Args:
            x(list): Vector of compostitions
            b(list): Vector of beta values
            potential_energy(list): Vector of potential energy values (E-mu*x)
            mu(list): Vector of mu values

        Returns:
            integrated_potential(list): List of grand canonical free energy values corresponding to a fixed mu value.
        """

        self.pot_eng[0] = self.energy_reference

        integrated_potential = []
        for index in range(len(self.b)):
            index = index + 1
            if index > 0:
                current_b = self.b[0:index]
                current_potential_energy = self.pot_eng[0:index]
                integrated_potential.append(
                    (1 / current_b[-1])
                    * (
                        self.b[0] * self.energy_reference
                        + integrate.simpson(current_potential_energy, current_b)
                    )
                )
        self.integ_grand_canonical = np.asarray(integrated_potential)


class cooling_run:
    """Class to parse CASM results from cooling Grand Canonical monte carlo calculations at constant chemical potential.

    Attributes
    ----------
    path: str
        Path to the directory containing the cooling results files.

    Methods
    -------
    get_constant_t_reference_energy:
        Function to look up the lte reference energy at a given chemical potential, from a constant temperature run object.
    """

    def __init__(self, cooling_dir, constant_t_run):
        self.path = cooling_dir
        results_file_path = os.path.join(self.path, "results.json")
        (
            self.mu,
            self.x,
            self.b,
            self.t,
            self.pot_eng,
            self.formation_energy,
        ) = read_mc_results_file(results_file_path)
        self.get_constant_t_reference_energy(constant_t_run)
        self.integrate_cooling_from_const_t_run()
        self.superdupercell = read_superdupercell(
            os.path.join(self.path, "mc_settings.json")
        )

    def get_constant_t_reference_energy(self, constant_t_run):
        mu_index = find(constant_t_run.mu, self.mu[0])
        self.energy_reference = constant_t_run.integ_grand_canonical[mu_index]

    def integrate_cooling_from_const_t_run(self):
        free_energy_reference = self.energy_reference
        integrated_potential = []
        for index, value in enumerate(self.b):
            index = index + 1
            if index > 0:
                current_b = self.b[0:index]
                current_potential_energy = self.pot_eng[0:index]
                integrated_potential.append(
                    (1 / current_b[-1])
                    * (
                        self.b[0] * free_energy_reference
                        + integrate.simpson(current_potential_energy, current_b)
                    )
                )
        self.integ_grand_canonical = np.asarray(integrated_potential)


def format_mc_settings(
    superdupercell: list,
    mu_init: float,
    mu_final: float,
    mu_increment: float,
    temp_init: float,
    temp_final: float,
    temp_increment: float,
    output_file: str,
    start_config_path: bool = False,
) -> None:
    """Function to format the CASM monte carlo settings json file file for a monte carlo run.

    Parameters:
    -----------
    superdupercell: list
        Tranformation matrix to apply to the CASM project primitive cell. Represented as a list of lists.
    mu_init: float
        Initial chemical potential value.
    mu_final: float
        Final chemical potential value.
    mu_increment: float
        Chemical potential increment value. Sign matters: if positive, it must follow that mu_final > mu_init. If negative, it must follow that mu_final < mu_init.
    temp_init: float
        Initial temperature value.
    temp_final: float
        Final temperature value.
    temp_increment: float
        Temperature increment value. Sign matters: if positive, it must follow that temp_final > temp_init. If negative, it must follow that temp_final < temp_init.
    output_file: str
        Path to the output file.
    start_config_path: str, optional
        Path to the starting configuration file, contained within one of the conditions.* files.

    Returns:
    --------
    None.
    """

    templates_path = os.path.join(mc_lib_dir, "../templates")
    # Read template
    with open(os.path.join(templates_path, "mc_grand_canonical_template.json")) as f:
        mc_settings = json.load(f)

    # Write settings
    mc_settings["supercell"] = superdupercell
    mc_settings["driver"]["initial_conditions"]["param_chem_pot"]["a"] = mu_init
    mc_settings["driver"]["initial_conditions"]["temperature"] = temp_init
    mc_settings["driver"]["final_conditions"]["param_chem_pot"]["a"] = mu_final
    mc_settings["driver"]["final_conditions"]["temperature"] = temp_final
    mc_settings["driver"]["incremental_conditions"]["param_chem_pot"][
        "a"
    ] = mu_increment
    mc_settings["driver"]["incremental_conditions"]["temperature"] = temp_increment

    if (start_config_path != False) and (start_config_path != None):
        mc_settings["driver"]["motif"]["configdof"] = start_config_path

    # write settings file
    with open(output_file, "w") as f:
        json.dump(mc_settings, f, indent="")


def run_cooling_from_const_temperature(
    mu_values: np.ndarray,
    mc_cooling_dir: str,
    const_temp_run_dir: str,
    temp_final: float,
    temperature_increment: float,
    job_scheduler: str = "slurm",
    submit_job: bool = False,
) -> None:
    """Runs many cooling Grand Canonical monte carlo calculations; each run is at different chemical potential. The calculations begin at the end state (atomic configuration) of a constant temperature calculation.

    Parameters:
    -----------
    mu_values: np.ndarray
        Array of chemical potential values to run the cooling calculation at.
    mc_cooling_dir: str
        Path to write all cooling calculations to.
    const_temp_run_dir: str
        Path to the directory containing the constant temperature run.
    temp_final: float
        Final temperature value.
    temperature_increment: float
        Temperature increment value. Sign matters: if positive, it must follow that temp_final > temp_init. If negative, it must follow that temp_final < temp_init.
    job_scheduler: str, optional
        Scheduler to use for the job. if not specified, will use slurm.
    submit_job: bool, optional
        Whether to submit the job. If False, will just write the job file. Default is False.
    """

    # read mu values, temperature information from the existing settings file
    (const_t_mu, x, b, temperature_values, potential_energy) = read_mc_results_file(
        os.path.join(const_temp_run_dir, "results.json")
    )
    superdupercell = read_superdupercell(
        os.path.join(const_temp_run_dir, "mc_settings.json")
    )
    # for each mu value, start a cooling run with the condition.# final state as the initial state (condition indexing starts at 0)
    for mu in mu_values:

        # Set up run directory
        run_name = "mu_%.4f_%.4f_T_%d_%d" % (mu, mu, temperature_values[0], temp_final)
        current_dir = os.path.join(mc_cooling_dir, run_name)
        if os.path.isfile(os.path.join(current_dir, "results.json")) == False:

            os.makedirs(current_dir, exist_ok=True)
            os.chdir(current_dir)

            # get const_t_mu index that matches mu
            mu_index = find(const_t_mu, mu)
            # Write settings file
            settings_file = os.path.join(current_dir, "mc_settings.json")
            start_config_path = os.path.join(
                const_temp_run_dir, "conditions.%d" % mu_index, "final_state.json"
            )

            format_mc_settings(
                superdupercell,
                mu,
                mu,
                0,
                temperature_values[0],
                temp_final,
                temperature_increment,
                settings_file,
                start_config_path,
            )

            # Run MC cooling
            if job_scheduler == "slurm":
                user_command = "casm monte -s mc_settings.json > mc_results.out"
                dj.format_slurm_job(
                    jobname="cool_" + run_name,
                    hours=20,
                    user_command=user_command,
                    output_dir=current_dir,
                    delete_submit_script=False,
                )
                if submit_job:
                    dj.submit_slurm_job(current_dir)
            """
            print("Submitting: ", end="")
            print(current_dir)
            os.system("casm monte -s mc_settings.json > mc_results.out &")
            """


def run_heating(
    mc_heating_dir: str,
    mu_values: np.ndarray,
    superdupercell: list,
    temp_init: float,
    temp_final: float,
    temp_increment: float,
    scheduler: str = "slurm",
    submit_job: bool = False,
) -> None:
    """Runs many heating Grand Canonical monte carlo calculations; each run is at different chemical potential.

    Parameters:
    -----------
    mc_heating_dir: str
        Path to write all heating calculations to.
    mu_values: np.ndarray
        Array of chemical potential values to run the heating calculation at.
    superdupercell: list
        Transformation matrix to apply on the CASM project primitive cell. Represented as a list of lists.
    temp_init: float
        Initial temperature value.
    temp_final: float
        Final temperature value.
    temp_increment: float
        Temperature increment value. Sign matters: if positive, it must follow that temp_final > temp_init. If negative, it must follow that temp_final < temp_init.
    scheduler: str, optional
        Scheduler to use for the job. if not specified, will use slurm.
    submit_job: bool, optional
        Whether to submit the job. If False, will just write the job file. Default is False.

    Returns:
    --------
    None.
    """

    for mu_value in mu_values:

        run_name = "mu_%.4f_%.4f_T_%d_%d" % (mu_value, mu_value, temp_init, temp_final)
        current_dir = os.path.join(mc_heating_dir, run_name)

        if os.path.isfile(os.path.join(current_dir, "results.json")) == False:
            os.makedirs(current_dir, exist_ok=True)
            os.chdir(current_dir)

            # Format settings file for this heating run
            settings_file = os.path.join(current_dir, "mc_settings.json")
            format_mc_settings(
                superdupercell,
                mu_value,
                mu_value,
                0,
                temp_init,
                temp_final,
                temp_increment,
                settings_file,
                start_config_path=False,
            )

            # Run MC heating
            user_command = "casm monte -s mc_settings.json > mc_results.out"
            if scheduler == "slurm":
                dj.format_slurm_job(
                    jobname="heat_" + run_name,
                    hours=20,
                    user_command=user_command,
                    output_dir=current_dir,
                    delete_submit_script=False,
                )
                if submit_job:
                    dj.submit_slurm_job(current_dir)
            """
            print("Submitting: ", end="")
            print(current_dir)
            os.system("casm monte -s mc_settings.json > mc_results.out &")
            """


def plot_const_t_x_vs_mu(const_t_left, const_t_right):
    print(
        "mc.mc.plot_const_t_x_vs_mu() is deprecated. Use plotting.mc_plotting.plot_const_t_x_vs_mu() instead."
    )
    full_mu = np.concatenate((const_t_left.mu, const_t_right.mu))
    full_x = np.concatenate((const_t_left.x, const_t_right.x))

    plt.scatter(full_x, full_mu, color="xkcd:crimson")
    plt.xlabel("Composition (a)", fontsize=18)
    plt.ylabel("Chemical Potential (a)", fontsize=18)
    fig = plt.gcf()
    fig.set_size_inches(15, 19)

    return fig


def plot_heating_and_cooling(heating_run, cooling_run):
    print(
        "mc.mc.plot_heating_and_cooling() is deprecated. Use plotting.mc_plotting.plot_heating_and_cooling() instead."
    )
    bullet_size = 3
    if heating_run.mu[0] != cooling_run.mu[0]:
        print(
            "WARNING: Chemical potentials do not match between the heating and cooling runs"
        )
    plt.title("Constant Mu: %.4f" % heating_run.mu[0])
    plt.xlabel("Temperature (K)", fontsize=18)
    plt.ylabel("Grand Canonical Free Energy", fontsize=18)
    plt.scatter(cooling_run.t, cooling_run.integ_grand_canonical, s=bullet_size)
    plt.scatter(heating_run.t, heating_run.integ_grand_canonical, s=bullet_size)
    plt.legend(["Cooling", "Heating"])
    fig = plt.gcf()
    fig.set_size_inches(15, 19)
    return fig


def predict_mu_vs_free_energy_crossing(
    const_t_run_1: constant_t_run, const_t_run_2: constant_t_run
) -> Tuple[float, float, float, float]:
    """Function to predict the free energy crossing chemical potential and compositions between two mu vs grand canonical plots

    Parameters:
    -----------
    const_t_run_1: constant_t_run
        A djlib constant_t_run object, containing the data for a constant temperature run
    const_t_run_2: constant_t_run
        A djlib constant_t_run object, containing the data for a constant temperature run

    Returns:
    --------
    mu_intersect_predict: float
        Predicted chemical potential at the crossing point in (chemical_potential vs grand canonical free energy) space
    energy_intersect_predict: float
        predicted grand canonical free energy at the crossing point in (chemical_potential vs grand canonical free energy) space
    run_1_comp_intersect: float
        composition for the first constant temperature run that is closest to the corresponding chemical potential at the crossing point
    run_2_comp_intersect: float
        composition for the second constant temperature run that is closest to the corresponding chemical potential at the crossing point

    """
    # Assert that the chemical potentials are the same
    assert np.allclose(
        np.sort(const_t_run_1.mu), np.sort(const_t_run_2.mu)
    ), "Chemical potentials do not match"

    # Ensure that all data is sorted by chemical potential
    mu_1 = const_t_run_1.mu[np.argsort(const_t_run_1.mu)]
    gc_free_energy_1 = const_t_run_1.integ_grand_canonical[np.argsort(const_t_run_1.mu)]
    x_1 = const_t_run_1.x[np.argsort(const_t_run_1.mu)]

    mu_2 = const_t_run_2.mu[np.argsort(const_t_run_2.mu)]
    gc_free_energy_2 = const_t_run_2.integ_grand_canonical[np.argsort(const_t_run_2.mu)]
    x_2 = const_t_run_2.x[np.argsort(const_t_run_2.mu)]

    # Fit a spline to the chemical potential vs grand canonical free energy data
    # Spline requires that domain (chemical potential) is strictly increasing
    interp_run_1 = scipy.interpolate.InterpolatedUnivariateSpline(
        mu_1, gc_free_energy_1
    )
    interp_run_2 = scipy.interpolate.InterpolatedUnivariateSpline(
        mu_2, gc_free_energy_2
    )

    # Define a difference function to be used in the root finding algorithm
    def difference(m):
        return np.abs(interp_run_1(m) - interp_run_2(m))

    # Find an initial guess for the root finding algorithm
    m0_index = np.argmin(abs(gc_free_energy_1 - gc_free_energy_2))
    m0_guess = mu_1[m0_index]

    # find the root of the difference function (chemical potential at crossing)
    mu_intersect_predict = scipy.optimize.fsolve(difference, x0=m0_guess)
    energy_intersect_predict = interp_run_1(mu_intersect_predict)

    # Find the calculated chemical potential that is closest to the predicted chemical potential
    mu_intersect_index_1 = np.argmin(abs(mu_intersect_predict - const_t_run_1.mu))
    mu_intersect_index_2 = np.argmin(abs(mu_intersect_predict - const_t_run_2.mu))

    # Find the crossing composition at a point mu, x that is actually calculated
    difference = np.abs(-mu_intersect_predict)

    run_1_comp_intersect = const_t_run_1.x[mu_intersect_index_1]
    run_2_comp_intersect = const_t_run_2.x[mu_intersect_index_2]
    return (
        mu_intersect_predict,
        energy_intersect_predict,
        run_1_comp_intersect,
        run_2_comp_intersect,
    )


def predict_free_energy_crossing(heating_run, cooling_run):
    """Function to find crossing point between two (energy vs T) curves.
    Args:
        heating_run(djlib.mc.heating_run):  Heating run object defined in djlib.mc
        cooling_run(djlib.mc.cooling_run): Cooling run object defined in djlib.mc
    Returns:
        tuple(
            t_intersect_predict,
            energy_intersect_predict, composition_intersect_predict
        )

    """
    # Check that lengths of all vectors match and that temp_heating == temp_cooling (i.e., they're not the reverse of each other)
    if (
        heating_run.integ_grand_canonical.shape[0]
        == heating_run.t.shape[0]
        == cooling_run.integ_grand_canonical.shape[0]
        == cooling_run.t.shape[0]
        == heating_run.x.shape[0]
        == cooling_run.x.shape[0]
    ):

        find_intersection = False
        if np.allclose(heating_run.t, cooling_run.t):
            find_intersection = True
        else:
            # If the temperature axes arent the same, try swapping the order of temp_cooling and cooling_integrated_free_energy.
            cooling_run.t = np.flip(cooling_run.t)
            cooling_run.integ_grand_canonical = np.flip(
                cooling_run.integ_grand_canonical
            )
            cooling_run.x = np.flip(cooling_run.x)

            # If the temperature axes still aren't the same, cancel the function.
            if np.allclose(heating_run.t, cooling_run.t):
                find_intersection = True
            else:
                print(
                    "Heating and cooling run temperature vectors are the same length but do not match. See printout below:\nheating_run  cooling_run"
                )
                for idx in range(len(heating_run.t)):
                    print("%.3f  %.3f" % heating_run.t[idx], cooling_run.t[idx])

        if find_intersection:
            # TODO: Check that there isn't more than one intersection (complete overlap) or no intersection.

            # fit spline to each dataset, calculate intersection
            interp_heating = scipy.interpolate.InterpolatedUnivariateSpline(
                heating_run.t, heating_run.integ_grand_canonical
            )
            interp_heating_comp = scipy.interpolate.InterpolatedUnivariateSpline(
                heating_run.t, heating_run.x
            )
            interp_cooling = scipy.interpolate.InterpolatedUnivariateSpline(
                cooling_run.t, cooling_run.integ_grand_canonical
            )
            interp_cooling_comp = scipy.interpolate.InterpolatedUnivariateSpline(
                cooling_run.t, cooling_run.x
            )

            # define a difference function to calculate the root
            def difference(t):
                return np.abs(interp_heating(t) - interp_cooling(t))

            # Provide a composition x0 as a guess for the root finder
            # This will break if there are multiple identical minimum values
            t0_index = np.argmin(
                abs(
                    heating_run.integ_grand_canonical
                    - cooling_run.integ_grand_canonical
                )
            )
            t0_guess = heating_run.t[t0_index]

            # Calculate the intersection point
            t_intersect_predict = scipy.optimize.fsolve(difference, x0=t0_guess)
            energy_intersect_predict = interp_heating(t_intersect_predict)
            composition_intersect_predict = interp_heating_comp(t_intersect_predict)

            return (
                t_intersect_predict,
                energy_intersect_predict,
                composition_intersect_predict,
            )

    else:
        print(
            "The free energies and composition vectors do not have the same lengths.\nCurrent lengths are:"
        )
        print("length of temp_heating: %d" % len(heating_run.t))
        print(
            "length of heating run integrated free energy: %d"
            % len(heating_run.integ_grand_canonical)
        )
        print("length of temp_cooling: %d" % len(cooling_run.t))
        print(
            "length of cooling run integrated free energy: %d"
            % len(cooling_run.integ_grand_canonical)
        )


def find_crossing_composition(
    integrated_energies, temperature, x, t_intersect_predict, energy_intersect_predict
):
    """Given an interpolated point in (energy vs temperature) space, find the closest existing (energy, temperature) and return the corresponding composition x and corresponding temperature.
    Args:
        integrated_energies(ndarray): Vector of integrated energy values.
        temperature(ndarray): Vector of temperature values (K).
        x(ndarray): Vector of composition values.
        t_intersect_predict(float): Interpolated prediction of the free energy crossing temperature between a heating and cooling grand canonical monte carlo simulation.
        energy_intersect_predict(float): Interpolated prediction of the free energy at the crossing temperature between a heating and cooling grand canonical monte carlo simulation.

    Returns:
        tuple(
            x_at_crossing(float): Composition at the actual coordinates closest to the predicted
            t_at_crossing(float): Temperature (K) at the actual coordinates closest to the predicted
        )
    """

    temperature_and_energy = np.zeros((len(temperature), 2))
    temperature_and_energy[:, 0] = temperature
    temperature_and_energy[:, 1] = integrated_energies

    prediction_point = np.array([t_intersect_predict, energy_intersect_predict])

    difference = temperature_and_energy - prediction_point

    distance = np.sum(np.abs(difference) ** 2, axis=-1) ** (1 / 2)
    closest_point_index = np.argmin(distance)

    x_at_crossing = x[closest_point_index]
    t_at_crossing = temperature[closest_point_index]
    return (x_at_crossing, t_at_crossing)


def simulation_is_complete(mc_run_dir):
    """Check that a grand canonical monte carlo simulation has finished
    Args:
        mc_run_dir(str): Path to a monte carlo simulation directory.

    Returns:
        simulation_status(bool): simulation is complete (True) or simulation is not complete (False)
    """
    # Check the number of conditions (mu, temp) that should be completed
    # TODO: read the results.json file instead of the number of conditions directories to see if a simulaiton is complete.
    mc_settings_file = os.path.join(mc_run_dir, "mc_settings.json")
    mu_values, temperature_values = read_mc_settings(mc_settings_file)

    target_t_length = temperature_values.shape[0]

    if os.path.isfile(os.path.join(mc_run_dir, "results.json")):
        mu, x, b, temperature, potential_energy = read_mc_results_file(
            os.path.join(mc_run_dir, "results.json")
        )
        if temperature.shape[0] == target_t_length.shape:
            simulation_status = True
        else:
            simulation_status = False
    else:
        print("Cannot find %s" % os.path.join(mc_run_dir, "results.json"))
        simulation_status = False
    return simulation_status


def plot_t_vs_x_rainplot(mc_runs_directory: str, show_labels: bool = False):
    """plot_rain_plots(mc_runs_directory, save_image_path=False, show_labels=False)

    Generate a single (T vs composition) plot using all monte carlo runs in mc_runs_directory.
    Args:
        mc_runs_directory(str): Path to the directory containing all grand canonical monte carlo runs.
        same_image(bool): Whether the image will be saved to the run directory or not.
        show_labels(bool): Whether or not the plot legend displays.

    Returns:
        fig(matplotlib.pyplot figure object): 2D plot object. Can do fig.show() to display the plot.
    """
    print(
        "mc.mc.plot_t_vs_x_rainplot() is deprecated. Use plotting.mc_plotting.plot_t_vs_x() instead."
    )
    labels = []
    run_list = glob(os.path.join(mc_runs_directory, "mu*"))
    for run in run_list:
        results_file = os.path.join(run, "results.json")
        if os.path.isfile(results_file):
            with open(results_file) as f:
                data = json.load(f)
                f.close()
                current_mc = run.split("/")[-1]
                labels.append(current_mc)
                composition = data["<comp(a)>"]
                temperature = data["T"]
                plt.scatter(composition, temperature)

    if show_labels:
        plt.legend(labels)
    plt.xlabel("Composition", fontsize=18)
    plt.ylabel("Temperature (K)", fontsize=18)
    fig = plt.gcf()
    fig.set_size_inches(18.5, 10)
    return fig


def constant_T_integration(t_const_run_data_dictionary):
    """
    Integrates the grand canonical free energy for a constant temperature run in temperature-chemical potential space.
    Currently Assumes there is one parameterized chemical potential

    Parameters
    ----------
    t_const_run_data_dictionary : dictionary
        Dictionary containing the data from a constant temperature run.

    Returns
    -------
    integrated_free_energy : np.ndarray
        Integrated grand canonical free energy in temperature-chemical potential space.
    """
    # Re-define necessary arrays as np.ndarrays
    free_energy_reference = np.array(t_const_run_data_dictionary["<potential_energy>"])[
        0
    ]
    mu = np.array(t_const_run_data_dictionary["param_chem_pot(a)"])
    x = np.array(t_const_run_data_dictionary["<comp(a)>"])

    # Calculate the grand canonical free energy
    integrated_potential = []
    for index in range(len(mu)):
        index = index + 1
        if index > 0:
            current_mu = mu[0:index]
            current_x = x[0:index]
            integrated_potential.append(
                free_energy_reference - integrate.simpson(current_x, current_mu)
            )
    return np.asarray(integrated_potential)


def LTE_integration(lte_run_data_dictionary):
    """Integrates the grand canonical free energy for a LTE run in temperature-chemical potential space.
    Currently Assumes there is one parameterized chemical potential

    Parameters
    ----------
    lte_run_data_dictionary : dictionary
        Dictionary containing the data from a LTE run. (Taken directly from a results.json file output by casm monte)

    Returns
    -------
    integrated_free_energy : np.ndarray
        Integrated grand canonical free energy in temperature-chemical potential space.
    """
    # Re-define necessary arrays as np.ndarrays
    b = np.array(lte_run_data_dictionary["Beta"])
    potential_energy = np.array(lte_run_data_dictionary["<potential_energy>"])
    mu = np.array(lte_run_data_dictionary["param_chem_pot(a)"])
    x = np.array(lte_run_data_dictionary["<comp(a)>"])

    # Calculate the grand canonical free energy
    integrated_potential = []
    for index, value in enumerate(b):
        index = index + 1
        if index > 0:
            current_b = b[0:index]
            current_potential_energy = potential_energy[0:index]
            current_mu = mu[0:index]
            current_x = x[0:index]
            integrated_potential.append(
                (1 / current_b[-1])
                * (
                    b[0] * potential_energy[0]
                    + integrate.simpson(
                        (current_potential_energy - current_mu * current_x), current_b
                    )
                )
            )
    return np.asarray(integrated_potential)


def heating_integration(heating_run_data_dictionary, LTE_reference_potential_energy):
    """
    Integrates the grand canonical free energy for a heating run in temperature-chemical potential space.
    Currently Assumes there is one parameterized chemical potential

    Parameters
    ----------
    heating_run_data_dictionary : dictionary
        Dictionary containing the data from a heating run. (Taken directly from a results.json file output by casm monte)
    LTE_reference_potential_energy : float
        The integrated grand canonical free energy of a heating run at the starting (chemical_potential, Temperature) point of the heating run.

    Returns
    -------
    integrated_free_energy : np.ndarray
        Integrated grand canonical free energy in temperature-chemical potential space.
    """
    # Re-define necessary arrays as np.ndarrays
    b = np.array(heating_run_data_dictionary["Beta"])
    potential_energy = np.array(heating_run_data_dictionary["<potential_energy>"])

    # Set the initial potential energy to the LTE reference potential energy
    potential_energy[0] = LTE_reference_potential_energy

    # Calculate the grand canonical free energy
    # integrated_potential = []
    # for index in range(len(b)):
    #    index = index + 1
    #    if index > 0:
    #        current_b = b[0:index]
    #        current_potential_energy = potential_energy[0:index]
    #        integrated_potential.append(
    #            (1 / current_b[-1])
    #            * (
    #                b[0] * potential_energy[0]
    #                + integrate.simpson(current_potential_energy, current_b)
    #            )
    #        )
    sgcfe = (
        b[0] * potential_energy[0]
        + cumulative_trapezoid(potential_energy, b, initial=potential_energy[0])
    ) / b
    sgcfe[0] = potential_energy[0]
    return np.array(sgcfe)


def constant_chemical_potential_integration(
    cooling_run_data_dictionary, constant_T_reference_potential_energy
):
    """
    Integrates the grand canonical free energy for a cooling run in temperature-chemical potential space.
    Requires a reference potential energy from a constant temperature run at the same chemical potential and initial temperature as the cooling run.
    Currently Assumes there is one parameterized chemical potential

    Notes
    -----
    the potential energy key refers to (E-mu x) in the results.json file output by casm monte

    Parameters
    ----------
    cooling_run_data_dictionary : dictionary
        Dictionary containing the data from a cooling run. (Taken directly from a results.json file output by casm monte)
    constant_T_reference_potential_energy : float
        The integrated grand canonical free energy of a constant temperature run at the same chemical potential and initial temperature as the cooling run.

    Returns
    -------
    integrated_free_energy : np.ndarray
        Integrated grand canonical free energy in temperature-chemical potential space.
    """
    # Re-define necessary arrays as np.ndarrays
    b = np.array(cooling_run_data_dictionary["Beta"])
    potential_energy = np.array(cooling_run_data_dictionary["<potential_energy>"])
    # Set the initial potential energy to the LTE reference potential energy
    potential_energy[0] = constant_T_reference_potential_energy

    # Calculate the grand canonical free energy
    sgcfe = (
        b[0] * constant_T_reference_potential_energy
        + cumulative_trapezoid(
            potential_energy, b, initial=constant_T_reference_potential_energy
        )
    ) / b
    sgcfe[0] = constant_T_reference_potential_energy

    # integrated_potential = []
    # for index in list(range(len(b))):
    #    index = index + 1
    #    if index > 0:
    #        current_b = b[0:index]
    #        current_potential_energy = potential_energy[0:index]
    #        integrated_potential.append(
    #            (1 / current_b[-1])
    #            * (
    #                b[0] * constant_T_reference_potential_energy
    #                + integrate.simpson((current_potential_energy), current_b)
    #            )
    #        )
    return np.array(sgcfe)


def lookup_LTE_reference_energy(T_lookup, LTE_run_data_dictionary):
    """
    To be used with heating integration. Assuming that the LTE run dictionary coresponds to a run at the same chemical potential as the heating run,
    this function finds the LTE reference potential energy at the starting temperature of the heating run.

    Parameters
    ----------
    T_lookup : float
        The temperature at which to find the LTE reference potential energy.
    LTE_run_data_dictionary : dictionary
        Dictionary containing the data from a LTE run. (Taken directly from a results.json file output by casm monte)

    Returns
    -------
    float
        The integrated grand canonical free energy of a LTE run at the temperature T_lookup.
    """
    # Read the phi_LTE (semi grand canonical free energy) from the LTE run data dictionary
    semi_grand_canonical_free_energy = np.array(LTE_run_data_dictionary["phi_LTE"])

    # Find the index of the temperature closest to the temperature at which to find the LTE reference potential energy
    T_index = np.argmin(np.abs(np.array(LTE_run_data_dictionary["T"]) - T_lookup))

    # Return the LTE reference potential energy at the starting temperature of the heating run
    return semi_grand_canonical_free_energy[T_index]


def lookup_constant_T_reference_energy(chemical_potential_lookup, constant_t_run_dict):
    """
    To be used with cooling integration. Assuming that the constant T run dictionary coresponds to a run at the same temperature as the cooling run,
    this function finds the constant T reference potential energy at the starting chemical potential of the cooling run.

    Parameters
    ----------
    chemical_potential_lookup : float
        The chemical potential at which to find the constant T reference potential energy.
    constant_t_run_dict : dictionary
        Dictionary containing the data from a constant temperature run. (Taken directly from a results.json file output by casm monte)

    Returns
    -------
    float
        The integrated grand canonical free energy of a constant temperature run at the chemical potential chemical_potential_lookup.
    """

    # Check if the "integrated_potential_energy" key exists in the constant T run dictionary.
    # If so, load it. Otherwise, calculate it.
    if "integrated_potential_energy" in constant_t_run_dict:
        constant_T_integrated_free_energy = np.array(
            constant_t_run_dict["integrated_potential_energy"]
        )
    else:
        constant_T_integrated_free_energy = constant_T_integration(constant_t_run_dict)

    # Find the index of the chemical potential closest to the chemical potential at which to find the constant T reference potential energy
    chemical_potential_index = np.argmin(
        np.abs(
            np.array(constant_t_run_dict["param_chem_pot(a)"])
            - chemical_potential_lookup
        )
    )

    # Return the constant T reference potential energy at the starting chemical potential of the cooling run
    return constant_T_integrated_free_energy[chemical_potential_index]


def lookup_closest_LTE_run(
    all_LTE_runs: np.ndarray, T_target, chemical_potential_target
):
    """
    Finds the LTE run that is closest to the target chemical potential.
    Returns the closest LTE run dictionary.

    Parameters
    ----------
    all_LTE_runs_list : list
        List of dictionaries containing the data from all LTE runs. (Each dictionary is taken directly from a results.json file output by casm monte)
    T_target : float
        The target temperature.
    chemical_potential_target : float
        The target chemical potential.

    Returns
    -------
    dictionary
        Dictionary containing the data from the LTE run closest to the target temperature and chemical potential.
    """
    # First, find the index of the LTE run that is closest to the target chemical potential
    chemical_potential_index = np.argmin(
        np.abs(
            np.array([run["param_chem_pot(a)"][0] for run in all_LTE_runs])
            - chemical_potential_target
        )
    )

    # Then, check that the target temperature is within the temperature range of the closest LTE run. If it is not, print a warning mesage.
    if not (
        min(all_LTE_runs[chemical_potential_index]["T"])
        <= T_target
        <= max(all_LTE_runs[chemical_potential_index]["T"])
    ):
        print(
            'Warning: Function "lookup_closest_LTE_run": The target temperature is outside the temperature range of the closest LTE run.'
        )

    # Return list index of the LTE run dictionary with the closest chemical potential
    return all_LTE_runs[chemical_potential_index]


def lookup_closest_constant_T_run(
    all_constant_T_runs: np.ndarray, T_target: float, chemical_potential_target: float
):
    """
    Finds the constant T run that is closest to the target temperature, and has an initial chemical potential that is closest to the target chemical potential.
    Returns the list index of the closest constant T run dictionary.

    Parameters
    ----------
    all_constant_T_runs_list : np.ndarray
        List of dictionaries containing the data from all constant temperature runs. (Each dictionary is taken directly from a results.json file output by casm monte)
    T_target : float
        The target temperature.
    chemical_potential_target : float
        The target chemical potential.

    Returns
    -------
    index
        List index of the constant T run dictionary with the closest temperature and chemical potential.
    """
    # If the runs array is not a numpy array, convert it to one
    if not isinstance(all_constant_T_runs, np.ndarray):
        all_constant_T_runs = np.array(all_constant_T_runs)

    # Iterate through all constant T runs, collect the temperatures of all the runs in a list
    all_T = np.array([run["T"][0] for run in all_constant_T_runs])

    # Find the indices of all constant T runs that have a temperature closest to the target temperature
    T_index = np.ravel(
        np.argwhere(np.abs(all_T - T_target) == np.min(np.abs(all_T - T_target)))
    ).astype(int)

    # Of this subset of constant T runs, find the index of the run that has an initial chemical potential closest to the target chemical potential.
    chemical_potential_index = np.argmin(
        np.abs(
            np.array([all_constant_T_runs[i]["param_chem_pot(a)"][0] for i in T_index])
            - chemical_potential_target
        )
    )

    # Return the dictionary of the constant T run with the closest temperature and chemical potential
    return all_constant_T_runs[T_index][chemical_potential_index]


def full_project_integration(project_gcmc_data: dict) -> dict:
    """
    Performs grand canonical free energy integration across all paths (Constant Temperature, LTE, Heating, Cooling) in a casm project.
    Takes a dictionary containing data from all grand canonical Monte Carlo runs in a casm project, and returns the same dictionary after appending 'integrated_potential_energy' keys and values to all runs.

    Parameters
    ----------
    project_gcmc_data : dictionary
        Dictionary containing the data from a full project. (Taken directly from a results.json file output by casm monte)

    Returns
    -------
    float
        The integrated grand canonical free energy at the target temperature and chemical potential.
    """

    # Iterate through all constant temperature runs, and append the integrated potential energy to each run dictionary.
    # Also, calculate and append the gibbs free energy to each run dictionary.
    for run_index in range(len(project_gcmc_data["T_const"])):
        project_gcmc_data["T_const"][run_index][
            "integrated_potential_energy"
        ] = constant_T_integration(project_gcmc_data["T_const"][run_index])

        project_gcmc_data["T_const"][run_index]["gibbs"] = project_gcmc_data["T_const"][
            run_index
        ]["integrated_potential_energy"] + np.array(
            project_gcmc_data["T_const"][run_index]["param_chem_pot(a)"]
        ) * np.array(
            project_gcmc_data["T_const"][run_index]["<comp(a)>"]
        )

    # Iterate through all heating runs, look up the LTE reference dictionary to find the reference potential energy, integrate the grand canonical free energy, and append the integrated potential energy to each run dictionary.
    for run_index in range(len(project_gcmc_data["heating"])):
        # Find the chemical potential, and the starting temperature of the heating run
        chemical_potential = project_gcmc_data["heating"][run_index][
            "param_chem_pot(a)"
        ][0]
        T_start = project_gcmc_data["heating"][run_index]["T"][0]

        # Look up the LTE run dictionary that is at this chemical potential
        closest_lte_dict = lookup_closest_LTE_run(
            project_gcmc_data["LTE"], T_start, chemical_potential
        )
        reference_energy = lookup_LTE_reference_energy(T_start, closest_lte_dict)

        # Integrate the grand canonical free energy, and append the integrated potential energy to the heating run dictionary
        project_gcmc_data["heating"][run_index][
            "integrated_potential_energy"
        ] = heating_integration(
            project_gcmc_data["heating"][run_index], reference_energy
        )

    # Iterate through all cooling runs, look up the constant temperature reference dictionary to find the reference potential energy, integrate the grand canonical free energy, and append the integrated potential energy to each run dictionary.
    for run_index in range(len(project_gcmc_data["cooling"])):
        # Find the chemical potential, and the starting temperature of the cooling run
        chemical_potential = project_gcmc_data["cooling"][run_index][
            "param_chem_pot(a)"
        ][0]
        T_start = project_gcmc_data["cooling"][run_index]["T"][0]

        # Look up the constant temperature run dictionary that is at this chemical potential
        closest_const_T_dict = lookup_closest_constant_T_run(
            project_gcmc_data["T_const"], T_start, chemical_potential
        )
        reference_energy = lookup_constant_T_reference_energy(
            chemical_potential, closest_const_T_dict
        )

        # Integrate the grand canonical free energy, and append the integrated potential energy to the cooling run dictionary
        project_gcmc_data["cooling"][run_index][
            "integrated_potential_energy"
        ] = constant_chemical_potential_integration(
            project_gcmc_data["cooling"][run_index], reference_energy
        )

    return project_gcmc_data


def find_heating_cooling_crossing(
    heating_run_dictionary: dict, cooling_run_dictionary: dict
) -> Tuple[float, float, float]:
    """
    Finds the nearest temperature at which the heating and cooling runs cross each other.
    Returns the composition at the crossing point
    """
    # Verify that the heating and cooling runs have the same temperature axis.
    # First, check that the length of the temperature axis is the same for both runs.
    assert (
        len(heating_run_dictionary["integrated_potential_energy"])
        == len(heating_run_dictionary["T"])
        == len(cooling_run_dictionary["integrated_potential_energy"])
        == len(cooling_run_dictionary["T"])
        == len(heating_run_dictionary["<comp(a)>"])
        == len(cooling_run_dictionary["<comp(a)>"])
    )

    find_intersection = False
    # IMPORTANT: The spline interpolation requires that the temperature axis be monotonically increasing.
    # The temperature axis is decreasing for the cooling run, so it needs to be flipped.
    # To avoid altering the original dictionary that is passed to the function, a temporary deep copy is made and flipped.
    # This is only necessary for the cooling run because the heating run is already in the correct order.
    if np.allclose(heating_run_dictionary["T"], cooling_run_dictionary["T"]):
        temporary_cooling_T = copy.deepcopy(cooling_run_dictionary["T"])
        temporary_cooling_integrated_free_energy = copy.deepcopy(
            cooling_run_dictionary["integrated_potential_energy"]
        )
        temporary_cooling_composition = copy.deepcopy(
            cooling_run_dictionary["<comp(a)>"]
        )
        find_intersection = True
    else:
        # If the temperature axes arent the same, try swapping the order of temp_cooling and cooling_integrated_free_energy.
        temporary_cooling_T = np.flip(copy.deepcopy(cooling_run_dictionary["T"]))
        temporary_cooling_integrated_free_energy = np.flip(
            copy.deepcopy(cooling_run_dictionary["integrated_potential_energy"])
        )
        temporary_cooling_composition = np.flip(
            copy.deepcopy(cooling_run_dictionary["<comp(a)>"])
        )

        # If the temperature axes still aren't the same, cancel the function.
        if np.allclose(heating_run_dictionary["T"], temporary_cooling_T):
            find_intersection = True
        else:
            print(
                "Heating and cooling run temperature vectors are the same length but do not match. See printout below:\nheating_run  cooling_run"
            )
            for idx in range(len(heating_run_dictionary["T"])):
                print(
                    "%.3f  %.3f" % heating_run_dictionary["T"][idx],
                    cooling_run_dictionary["T"][idx],
                )

    if find_intersection:
        # Take the heating run temperature array.
        # Find the minimum and maximum, and the difference between them.
        # Create a linspace array with double the number of points as the difference between the min and max.
        # Use np.interp to interpolate the heating integrated_potential vs T and the cooling integrated_potential vs T.
        # Also use np.interp to interpolate the heating composition vs T and the cooling composition vs T.
        # Find the index of the minimum difference between the two interpolated integrated_potential vs T arrays.
        # Return the temperature at that index, and the two compositions at that index.

        # Find the minimum and maximum temperature of the heating run
        T_min = np.min(heating_run_dictionary["T"])
        T_max = np.max(heating_run_dictionary["T"])
        T_diff = T_max - T_min

        # Create a linspace array with double the number of points as the difference between the min and max
        T_linspace = np.linspace(T_min, T_max, 2 * int(T_diff))

        # Interpolate the heating and cooling runs to the linspace array
        heating_integrated_potential_interp = np.interp(
            T_linspace,
            heating_run_dictionary["T"],
            heating_run_dictionary["integrated_potential_energy"],
        )
        cooling_integrated_potential_interp = np.interp(
            T_linspace, temporary_cooling_T, temporary_cooling_integrated_free_energy
        )

        heating_composition_interp = np.interp(
            T_linspace, heating_run_dictionary["T"], heating_run_dictionary["<comp(a)>"]
        )
        cooling_composition_interp = np.interp(
            T_linspace, temporary_cooling_T, temporary_cooling_composition
        )

        # Find the index of the minimum difference between the two interpolated integrated_potential vs T arrays
        crossing_index = np.argmin(
            abs(
                heating_integrated_potential_interp
                - cooling_integrated_potential_interp
            )
        )

        # Return the interpolated temperature, semi grand canonical free energy, heating composition and cooling composition at the crossing point
        return (
            T_linspace[crossing_index],
            heating_integrated_potential_interp[crossing_index],
            heating_composition_interp[crossing_index],
            cooling_composition_interp[crossing_index],
        )

        # fit spline to each dataset, calculate intersection
        # interp_heating = scipy.interpolate.InterpolatedUnivariateSpline(
        #    heating_run_dictionary["T"],
        #    heating_run_dictionary["integrated_potential_energy"],
        # )
        # interp_heating_comp = scipy.interpolate.InterpolatedUnivariateSpline(
        #    heating_run_dictionary["T"], heating_run_dictionary["<comp(a)>"]
        # )
        # interp_cooling = scipy.interpolate.InterpolatedUnivariateSpline(
        #    temporary_cooling_T, temporary_cooling_integrated_free_energy,
        # )
        # interp_cooling_comp = scipy.interpolate.InterpolatedUnivariateSpline(
        #    temporary_cooling_T, temporary_cooling_composition
        # )

        # This will break if there are multiple identical minimum values
        # t0_index = np.argmin(
        #    abs(
        #        heating_run_dictionary["integrated_potential_energy"]
        #        - temporary_cooling_integrated_free_energy
        #    )
        # )
        # t0_guess = heating_run_dictionary["T"][t0_index]

        # Calculate the intersection point
        # t_intersect_predict = scipy.optimize.fsolve(difference, x0=t0_guess)
        # energy_intersect_predict = interp_heating(t_intersect_predict)
        # composition_intersect_predict_heating = interp_heating_comp(t_intersect_predict)
        # composition_intersect_predict_cooling = interp_cooling_comp(t_intersect_predict)

        # return (
        #    t_intersect_predict,
        #    energy_intersect_predict,
        #    composition_intersect_predict_heating,
        #    composition_intersect_predict_cooling,
        # )


def find_constant_T_crossing(
    constant_T_dict_1: dict, constant_T_dict_2: dict
) -> Tuple[float, float, float]:
    """
    Finds the nearest chemical potential at which the two constant temperature runs cross each other in (chemical_potential, Temperature) space.
    Returns the composition at the crossing point

    Parameters
    ----------
    constant_T_dict_1 : dictionary
        Dictionary for the first constant temperature run
    constant_T_dict_2 : dictionary
        Dictionary for the second constant temperature run

    Returns
    -------
    mu_intersect_predict : float
        Chemical potential at the intersection point
    energy_intersect_predict : float
        integrated grand canonical free energy at the intersection point.
    composition_intersect_predict : float
        Composition at the intersection point.
    """

    # Assert that the chemical potentials are the same
    assert np.allclose(
        np.sort(constant_T_dict_1["param_chem_pot(a)"]),
        np.sort(constant_T_dict_2["param_chem_pot(a)"]),
    ), "Chemical potentials do not match"

    # Ensure that all data is sorted by chemical potential
    mu_1 = np.array(constant_T_dict_1["param_chem_pot(a)"])[
        np.argsort(constant_T_dict_1["param_chem_pot(a)"])
    ]
    gc_free_energy_1 = constant_T_dict_1["integrated_potential_energy"][
        np.argsort(constant_T_dict_1["param_chem_pot(a)"])
    ]
    x_1 = np.array(constant_T_dict_1["<comp(a)>"])[
        np.argsort(constant_T_dict_1["param_chem_pot(a)"])
    ]

    mu_2 = np.array(constant_T_dict_2["param_chem_pot(a)"])[
        np.argsort(constant_T_dict_2["param_chem_pot(a)"])
    ]
    gc_free_energy_2 = constant_T_dict_2["integrated_potential_energy"][
        np.argsort(constant_T_dict_2["param_chem_pot(a)"])
    ]
    x_2 = np.array(constant_T_dict_2["<comp(a)>"])[
        np.argsort(constant_T_dict_2["param_chem_pot(a)"])
    ]

    # Find the minimum and maximum chemical potentials, and create a linspace array between the minimum and maximum values incrementing by 0.001.
    mu_min = np.min([np.min(mu_1), np.min(mu_2)])
    mu_max = np.max([np.max(mu_1), np.max(mu_2)])
    mu_diff = int(np.abs(mu_max - mu_min))
    mu_linspace = np.linspace(mu_min, mu_max, mu_diff * 1000)

    # Create a piecewise linear interpolation of the  semi grand canonical free energy vs chemical potential for each run using np.interp.
    # Also create a piecewise linear interpolation of the composition vs chemical potential for each run using np.interp.
    gc_free_energy_1_interp = np.interp(mu_linspace, mu_1, gc_free_energy_1)
    gc_free_energy_2_interp = np.interp(mu_linspace, mu_2, gc_free_energy_2)
    x_1_interp = np.interp(mu_linspace, mu_1, x_1)
    x_2_interp = np.interp(mu_linspace, mu_2, x_2)

    # Find the index of the minimum difference between the two interpolated semi grand canonical free energy functions
    min_diff_index = np.argmin(abs(gc_free_energy_1_interp - gc_free_energy_2_interp))

    # Return the chemical potential, integrated grand canonical free energy, and two compositions at the minimum difference index
    return (
        mu_linspace[min_diff_index],
        gc_free_energy_1_interp[min_diff_index],
        x_1_interp[min_diff_index],
        x_2_interp[min_diff_index],
    )

    # interp_run_1 = scipy.interpolate.InterpolatedUnivariateSpline(
    #    mu_1, gc_free_energy_1
    # )
    # interp_run_2 = scipy.interpolate.InterpolatedUnivariateSpline(
    #    mu_2, gc_free_energy_2
    # )

    # Define a difference function to be used in the root finding algorithm
    # def difference(m):
    #    return np.abs(interp_run_1(m) - interp_run_2(m))

    # Find an initial guess for the root finding algorithm
    # m0_index = np.argmin(abs(gc_free_energy_1 - gc_free_energy_2))
    # m0_guess = mu_1[m0_index]

    # find the root of the difference function (chemical potential at crossing)
    # mu_intersect_predict = scipy.optimize.fsolve(difference, x0=m0_guess)
    # energy_intersect_predict = interp_run_1(mu_intersect_predict)

    # Find the calculated chemical potential that is closest to the predicted chemical potential
    # mu_intersect_index_1 = np.argmin(
    #    abs(mu_intersect_predict - constant_T_dict_1["param_chem_pot(a)"])
    # )
    # mu_intersect_index_2 = np.argmin(
    #   abs(mu_intersect_predict - constant_T_dict_2["param_chem_pot(a)"])
    # )

    # Find the crossing composition at a point mu, x that is actually calculated
    # difference = np.abs(-mu_intersect_predict)

    # run_1_comp_intersect = constant_T_dict_1["<comp(a)>"][mu_intersect_index_1]
    # run_2_comp_intersect = constant_T_dict_2["<comp(a)>"][mu_intersect_index_2]
    # return (
    #    mu_intersect_predict,
    #    energy_intersect_predict,
    #    run_1_comp_intersect,
    #    run_2_comp_intersect,
    # )


def order_disorder_crossing_points(project_gcmc_data: dict):
    """
    Calculates the points in (composition,Temperature) space where free energy curves cross, indicating an order-disorder transition.
    Currently only works for a binary system.

    Parameters
    ----------
    project_gcmc_data : dictionary
        Dictionary containing the GCMC data for the project. This includes all four types of calculation paths: Constant Temperature, LTE, Heating and Cooling.

    Returns
    -------
    crossing_points:list
        List of dictionaries containing the temperature, composition, chemical potential and integrated grand canonical free energy at each order-disorder transition.
        Also includes the path type that the transition was calculated from. Options are 'fixed_T' or 'fixed_chemical_potential'.
        For fixed temperature paths, the crossing in (chemical_potential,energy) space has two corresponding compositions. Both are returned.
        For fixed chemical potential paths, the crossing in (Temperature,energy) space has one corresponding composition.
    """
    # Run full project integration on the data to ensure that all integrated free energies are calculated.
    project_gcmc_data = full_project_integration(project_gcmc_data)

    # Initialize the list of crossing points
    crossing_points = []

    # First, check for order-disorder transitions in the constant temperature runs.
    # Constant temperature runs come in pairs at a given temperature. Find and pair them.
    constant_T_runs = project_gcmc_data["T_const"]
    constant_T_temperatures = np.unique([run["T"][0] for run in constant_T_runs])
    constant_T_run_pairs = []
    for T in constant_T_temperatures:
        temporary_pair = [run for run in constant_T_runs if run["T"][0] == T]
        if len(temporary_pair) > 1:
            constant_T_run_pairs.append(temporary_pair)

    # Iterate through the pairs of constant temperature runs and find the crossing points.
    # Append the crossing points to the list of crossing points as a dictionary.
    for pair in constant_T_run_pairs:
        (
            mu_intersect_predict,
            energy_intersect_predict,
            x_intersect_1,
            x_intersect_2,
        ) = find_constant_T_crossing(pair[0], pair[1])
        crossing_points.append(
            {
                "T": pair[0]["T"][0],
                "x_1": x_intersect_1,
                "x_2": x_intersect_2,
                "mu": mu_intersect_predict,
                "free_energy": energy_intersect_predict,
                "path_type": "fixed_T",
            }
        )

    # Next, check for order-disorder transitions in the fixed chemical potential runs.
    # Fixed chemical potential runs come in pairs at a given chemical potential. Find and pair them.
    heating_runs = project_gcmc_data["heating"]
    cooling_runs = project_gcmc_data["cooling"]
    fixed_chem_potential_runs = heating_runs + cooling_runs

    fixed_chem_potential_chem_pots = np.unique(
        [run["param_chem_pot(a)"][0] for run in fixed_chem_potential_runs]
    )
    fixed_chem_potential_run_pairs = []
    for mu in fixed_chem_potential_chem_pots:
        fixed_chem_potential_run_pairs.append(
            [
                run
                for run in fixed_chem_potential_runs
                if run["param_chem_pot(a)"][0] == mu
            ]
        )

    # Iterate through the pairs of fixed chemical potential runs and find the crossing points.
    # Append the crossing points to the list of crossing points as a dictionary.
    for pair in fixed_chem_potential_run_pairs:
        (
            T_intersect_predict,
            energy_intersect_predict,
            x_intersect_predict_heating,
            x_intersect_predict_cooling,
        ) = find_heating_cooling_crossing(pair[0], pair[1])
        crossing_points.append(
            {
                "T": T_intersect_predict,
                "x_1": x_intersect_predict_heating,
                "x_2": x_intersect_predict_cooling,
                "mu": pair[0]["param_chem_pot(a)"][0],
                "free_energy": energy_intersect_predict,
                "path_type": "fixed_chemical_potential",
            }
        )

    # TODO: This function currently returns predicted crossing points that are interpolated from the data.
    # If it is necessary to only use actual calculated points, this can be done using the "find_crossing_composition" function in this module.
    return crossing_points
